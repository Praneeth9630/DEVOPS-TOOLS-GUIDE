
#########################################################---------------- DOCKER ---------------------- ##################################################################################


## ----- Docker overview ----------##
Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Docker's methodologies for shipping, testing, and deploying code, you can significantly reduce the delay between writing code and running it in production.

###########################################################################################################################################################################################

MONOLITHIC: Deploying monolithic applications is more straightforward than deploying microservices. Developers install the entire application code base and dependencies in a single environment.

MICRO SERVICES: Microservices are deployed using VM or Containers. Containers are the preferred deployment route for microservices as containers are lighter, portable, and modular. The microservice code is packaged into a container image and deployed as a container service.
multiple services are deployed on multiple servers with multiple databases.

note: if number of application are more will go with microservices concept (docker and kubernetes)

BASED ON USERS AND APP COMPLEXITY WE NEED TO SELECT THE ARCHITECTURE.

FACTORS AFFECTIONG FOR USING MICRO SERVICES:
FLEXIBLE
COST 
MAINTAINANCE
EASY CONTROL

###########################################################################################################################################################################################

DOCKER IMAGE:
Docker images are read-only templates that contain instructions for creating a container. A Docker image is a snapshot or blueprint of the libraries and dependencies required inside a container for an application to run

CONTAINERS:
A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime
its same as a server/vm.
it will not have any operating system.
 (Ec2 server=AMI, CONTAINER=IMAGE)
os will be maanged in image

#######################################################################################################################################################################################

------------# Docker file runn commands #----------
Dockerfile is a simple text file that consists of instructions to build Docker images.
-----------------------------------
##### Docker file instruiction ########

From : to pull base image
Run : to excutive commands
CMD : To Provide defaults for an executing container 
Entrypoint : To configure a container that will run as an container
Workdir : to set working directory
Copy: files form local to the container
Add: TO copy files and loader file but little advance add command we can add url also 
Expose : informs docker that the container listen on the specified network port runtime
Env: To set env variabels 

######################################################################################################################################################################################
##Docker registery--> https://hub.docker.com/_/httpd
######################################################################################################################################################################################


######################################################################################################################################################################################
                                                                        ----- Docker DAY-1 -------    
######################################################################################################################################################################################
                                                             
-----docker install process -------
-->sudo yum install docker -y
-->sudo systemctl start docker
-->sudo systemctl status docker
-->docker --version
   -->Docker version 25.0.3, build 4debf41
-->docker version
   -->Client:
      Version:           25.0.3
      API version:       1.44
      Go version:        go1.20.12
      Git commit:        4debf41
      Built:             Mon Feb 12 00:00:00 2024
      OS/Arch:           linux/amd64
      Context:           default
      permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get "http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version": dial unix 
      /var/run/docker.sock: connect: permission denied
   -->Here we are only able to see only client and missing the server(docker daemonor docker host), if there is no server then your request will not go to registry.
-->sudo chmod 666 /var/run/docker.sock
   -->to give access docker demon to run docker server 
-->docker version
  -->Client:
      Version:           25.0.3
      API version:       1.44
      Go version:        go1.20.12
      Git commit:        4debf41
      Built:             Mon Feb 12 00:00:00 2024
      OS/Arch:           linux/amd64
      Context:           default

    Server:
      Engine:
      Version:          25.0.3
      API version:      1.44 (minimum version 1.24)
     Go version:       go1.20.12
     Git commit:       f417435
     Built:            Mon Feb 12 00:00:00 2024
     OS/Arch:          linux/amd64
     Experimental:     false
     containerd:
     Version:          1.7.11
     GitCommit:        64b8a811b07ba6288238eefc14d898ee0b5b99ba
   runc:
     Version:          1.1.11
     GitCommit:        4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06
     docker-init:
     Version:          0.19.0
     GitCommit:        de40ad0
-->sudo usermod -a -G docker ec2-user
   -->as docker needs every time root user, we are adding ec2-user to docker group to operate from ec2-user
-->docker images
  -->REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
  -->At present there are no images.
-->docker pull ubuntu
   -->to pull base images from public docker repository
-->docker images
  -->REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
     ubuntu       latest    ca2b0f26964c   2 weeks ago   77.9MB
-->ps -ef | wc -l
  -->117
  -->but i am not using anything but still showing current running process as 117.
-->docker pull nginx
-->docker images
   -->REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
      ubuntu       latest    ca2b0f26964c   2 weeks ago   77.9MB
      nginx        latest    92b11f67642b   4 weeks ago   187MB
-->docker run -it ubuntu /bin/bash
   -->when we run this cmd, in linux it will show root@7fe1ae3a6028:/#--here 7fe1ae3a6028 means container number.
   -->will run the image to create the container and also enter the container interact terminal.
-->ls
   -->bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
   --> it is the same as other linux's.
-->ps -ef | wc-l
   -->4
   -->as the containers will have very less dependencies.
-->1.if you want to come out from connainer without stoping the container give "ctrl+pq"
   2.if you give "exit"  container also will stop
-->Cntl+pq
  -->Now you are back to ec2-user and container is still running.
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
      7fe1ae3a6028   ubuntu    "/bin/bash"   44 minutes ago   Up 44 minutes             charming_cori
   -->to check running containers
-->docker ps -a
  -->CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
     7fe1ae3a6028   ubuntu    "/bin/bash"   45 minutes ago   Up 45 minutes             charming_cori
  -->to check both running and stopped containers
-->docker stop 7fe1ae3a6028
   -->to stop container
   -->we can give cmd either docker stop <containerid> or docker stop <container name>
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-->docker ps -a
   -->CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                        PORTS     NAMES
      7fe1ae3a6028   ubuntu    "/bin/bash"   49 minutes ago   Exited (137) 24 seconds ago             charming_cori
-->docker start 7fe1ae3a6028  
   -->7fe1ae3a6028  
-->docker run -dt nginx 
   -->will run the image to create the container and not enter the container detach terminal.
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS         PORTS     NAMES
      3b3aa84af8c6   nginx     "/docker-entrypoint.…"   5 seconds ago    Up 4 seconds   80/tcp    exciting_rosalind
      7fe1ae3a6028   ubuntu    "/bin/bash"              53 minutes ago   Up 2 minutes             charming_cori
-->docker exec -it 3b3aa84af8c6 /bin/bash
   --> it will let us into the container nginx.
   -->in linux it will take us to this root@3b3aa84af8c6:/#.
-->Cntl+pq
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS         PORTS     NAMES
      3b3aa84af8c6   nginx     "/docker-entrypoint.…"   5 minutes ago    Up 5 minutes   80/tcp    exciting_rosalind
      7fe1ae3a6028   ubuntu    "/bin/bash"              59 minutes ago   Up 8 minutes             charming_cori
-->docker inspect 3b3aa84af8c6
   -->to get complete info of a container
-->docker images
   -->REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
      ubuntu       latest    ca2b0f26964c   2 weeks ago   77.9MB
      nginx        latest    92b11f67642b   4 weeks ago   187MB
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS          PORTS     NAMES
      3b3aa84af8c6   nginx     "/docker-entrypoint.…"   11 minutes ago      Up 11 minutes   80/tcp    exciting_rosalind
      7fe1ae3a6028   ubuntu    "/bin/bash"              About an hour ago   Up 14 minutes             charming_cori
-->docker rm 3b3aa84af8c6
   -->Error response from daemon: cannot remove container "/exciting_rosalind": container is running: stop the container before removing or force remove
   -->So as the container is running we cannot remove the container.
-->docker stop 3b3aa84af8c6
   -->3b3aa84af8c6
-->docker rm 3b3aa84af8c6
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND       CREATED             STATUS          PORTS     NAMES
      7fe1ae3a6028   ubuntu    "/bin/bash"   About an hour ago   Up 18 minutes             charming_cori
-->docker rm -f 7fe1ae3a6028
   -->7fe1ae3a6028
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-->docker ps -a
   -->CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-->docker images
   -->REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
      ubuntu       latest    ca2b0f26964c   2 weeks ago   77.9MB
      nginx        latest    92b11f67642b   4 weeks ago   187MB
-->docker rmi ubuntu
   -->cmd to delete a image.
-->docker images
   -->REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
      nginx        latest    92b11f67642b   4 weeks ago   187MB
-->## danger commands## 
        1)docker system prune -a to remove all images 
        2)docker container prune -- delete all stopped containers 
        3)docker rm -f $(docker ps -a -q)  ---delete all runnig containers Note: please dont use danger command
-->docker run -dt nginx 
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
      57b22f99a4fd   nginx     "/docker-entrypoint.…"   4 seconds ago   Up 4 seconds   80/tcp    compassionate_jepsen
-->docker run -dt nginx 
-->docker run -dt nginx 
-->docker run -dt nginx 
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES
      d67888847d21   nginx     "/docker-entrypoint.…"   5 seconds ago    Up 4 seconds    80/tcp    crazy_blackburn
      c28d91733426   nginx     "/docker-entrypoint.…"   7 seconds ago    Up 6 seconds    80/tcp    hopeful_lamport
      c2dc23599f8f   nginx     "/docker-entrypoint.…"   12 seconds ago   Up 11 seconds   80/tcp    relaxed_mccarthy
      57b22f99a4fd   nginx     "/docker-entrypoint.…"   2 minutes ago    Up 2 minutes    80/tcp    compassionate_jepsen
   -->By this we can see that we can run multiple times sames image to create new containers.
-->docker rm -f $(docker ps -a -q)
   -->d67888847d21
      c28d91733426
      c2dc23599f8f
      57b22f99a4fd
   -->It will delete all the containers.
-->docker images 
   -->REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
      nginx        latest    92b11f67642b   4 weeks ago   187MB
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-->docker run -dt --name ngnixcontainer nginx  
   -->We run the cmd docker run -dt --name <name> <imagename> --------to give custome name --name.
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
      4d1c4a15ab81   nginx     "/docker-entrypoint.…"   7 seconds ago   Up 6 seconds   80/tcp    ngnixcontainer
-->docker run -dt --name ngnixcontainer nginx  
   -->docker: Error response from daemon: Conflict. The container name "/ngnixcontainer" is already in use by container "4d1c4a15ab816f26a71df9f01aa34dd638f5e5cec569958daecacd196e2a5941".
      You have to remove (or rename) that container to be able to reuse that name.  
      See 'docker run --help' 
   --> So we cant create another container with same name.  
-->docker run -dt -p 8080:80 --name ngnixcontainer2 nginx 
   -->here 80 is default port for application and 8080 is the custom port for the application.
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES
      8d92c9023727   nginx     "/docker-entrypoint.…"   3 seconds ago   Up 3 seconds   0.0.0.0:8080->80/tcp, :::8080->80/tcp   ngnixcontainer2
      4d1c4a15ab81   nginx     "/docker-entrypoint.…"   6 minutes ago   Up 6 minutes   80/tcp                                  ngnixcontainer
-->Now we can access the application in google by giving <public_Ip_of_instance>:8080.


#####################################################################################################################################################################################
                                                                        ----- Docker DAY-2 -------    
#####################################################################################################################################################################################


-->docker rm -f $(docker ps -a -q)
-->docker ps
  -->CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
-->docker system prune -a
-->docker images
   -->REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
-->docker pull jenkins/jenkins
-->docker images
   -->REPOSITORY        TAG       IMAGE ID       CREATED      SIZE
      jenkins/jenkins   latest    cd151a63c5c9   3 days ago   462MB
-->docker run -dt -p 8081:8080 --name jenkins-container jenkins/jenkins
   -->we use this cmd ---- docker run -dt -p <local host port>:<container run port> --name <name of the container> <name of the image>
-->docker ps
   -->CONTAINER ID   IMAGE             COMMAND                  CREATED         STATUS         PORTS                                                  NAMES
      16a5b27a18e9   jenkins/jenkins   "/usr/bin/tini -- /u…"   4 seconds ago   Up 3 seconds   50000/tcp, 0.0.0.0:8081->8080/tcp, :::8081->8080/tcp   jenkins-container
-->Now we can access the Jenkins webpage by giving <public_ip_of_instance>:8081
-->docker exec -it jenkinscontainer1 /bin/bash
-->jenkins@7e115f0dd720:/$ cat /var/jenkins_home/secrets/initialAdminPassword
                           -->3daa09e7525d4864a3eb461041e5d1d8
-->Now we can access jenkins fully.
-->git clone https://github.com/CloudTechDevOps/Docker_web.git
-->ls
   -->Docker_web
-->cd Docker_web
-->ls
   -->Dockerfile  README.md  index.html  style.css
-->vi Dockerfile
   -->FROM httpd:2.4
      COPY . /usr/local/apache2/htdocs/
   -->here apache server works on /usr/local/apache2/htdocs/ this path and in COPY the . means all files in current directory
-->docker build -t custom_image_1 .
   -->command to run docker file
-->docker images
   -->REPOSITORY        TAG       IMAGE ID       CREATED          SIZE
      custom_image_1    latest    6ff5d23be26a   18 seconds ago   148MB
      jenkins/jenkins   latest    8e7bd57a40fa   27 hours ago     470MB
-->docker run -dt -p 8082:80 --name httpd custom_image_1
-->Now we can access the application webpage by giving <public_ip_of_instance>:8082
-->Now lets create one project and run it on a container.
-->cd ~
-->mkdir web1
-->cd web1
-->vi index.html
   -->welcome to devops and aws Mr.Praneeth
-->vi Dockerfile
   -->FROM httpd:2.4
      COPY index.html /var/www/html
-->docker rm -f $(docker ps -a -q)
   -->to delete current containers.
-->docker system prune -a
   -->To delete all images.
-->[ec2-user@ip-10-0-1-189 web1]$ docker build -t httpd .
-->docker run -dt -p 8081:80 --name httpd_container httpd
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND              CREATED         STATUS         PORTS                                   NAMES
      4f891972314d   httpd     "httpd-foreground"   4 seconds ago   Up 3 seconds   0.0.0.0:8081->80/tcp, :::8081->80/tcp   httpd_container
-->Now we can access the application webpage by giving <public_ip_of_instance>:8081, but here in web page it only shows it works so we gave some wrong info in Dockerfile.
-->vi Dockerfile
   -->FROM httpd:2.4
      COPY index.html  /usr/local/apache2/htdocs/
-->[ec2-user@ip-10-0-1-189 web1]$ docker build -t httpd2 .
-->docker run -dt -p 8082:80 --name httpd_container_2 httpd2
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND              CREATED         STATUS         PORTS                                   NAMES
      ec898f7068d5   httpd2    "httpd-foreground"   4 seconds ago   Up 4 seconds   0.0.0.0:8082->80/tcp, :::8082->80/tcp   httpd_container_2
      4f891972314d   httpd     "httpd-foreground"   7 minutes ago   Up 6 minutes   0.0.0.0:8081->80/tcp, :::8081->80/tcp   httpd_container
-->Now we can access the application webpage by giving <public_ip_of_instance>:8082.
-->Now lets try httpd with ubuntu (impliment from scratch)
-->cd ..
-->ls
   -->Docker_web  web1
-->cd Docker_web
-->ls
   -->Dockerfile  README.md  index.html  style.css
-->vi Dockerfile
   -->FROM ubuntu #pull ubuntu base image from docker hub
      RUN apt update
      RUN apt-get -y  update
      RUN apt-get -y install apache2 #by using RUN instrcution install apache2
      COPY .  /var/www/html #copying index.html file into /var/www/html
      EXPOSE 80 #expose default port number for application
      CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"] #Run apache2 server while running container from image
-->Note: -D FOREGROUND This is not a docker command this is Apache server argument which is used to run the web server in the background. If we do not use this argument the server will 
          start and then it will stop
-->[ec2-user@ip-10-0-1-189 Docker_web]$ docker build -t webserver1 .
-->docker images
   -->REPOSITORY   TAG       IMAGE ID       CREATED              SIZE
      webserver1   latest    8402b549b08e   About a minute ago   236MB
      httpd2       latest    c368da710da1   36 minutes ago       167MB
      httpd        latest    bf308a6b9277   44 minutes ago       167MB
-->docker run -dt -p 8083:80 --name webcontainer webserver1
-->docker ps
   -->CONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS          PORTS                                   NAMES
      3c6bc7b2ef19   webserver1   "/usr/sbin/apache2ct…"   4 seconds ago    Up 3 seconds    0.0.0.0:8083->80/tcp, :::8083->80/tcp   webcontainer
      ec898f7068d5   httpd2       "httpd-foreground"       38 minutes ago   Up 38 minutes   0.0.0.0:8082->80/tcp, :::8082->80/tcp   httpd_container_2
      4f891972314d   httpd        "httpd-foreground"       45 minutes ago   Up 45 minutes   0.0.0.0:8081->80/tcp, :::8081->80/tcp   httpd_container
-->Now we can access the application webpage by giving <public_ip_of_instance>:8083.
-->Now lets try python project.
-->git clone https://github.com/Praneeth9630/docker_python_flask-project.git
-->ls
   -->Docker_web  docker_python_flask-project  web1
-->cd docker_python_flask-project
-->ls 
   -->Dockerfile  README.md  app.py  requirements.txt
-->vi Dockerfile
   -->FROM python:3.6
      MAINTAINER veera "veera.narni232@gmail.com"
      COPY . /app
      WORKDIR /app
      RUN pip install -r requirements.txt
      ENTRYPOINT ["python"]
      CMD ["app.py"]
-->docker build -t webserver2 .
-->docker images
   -->REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
      webserver2   latest    50b30d9a1977   48 seconds ago   913MB
      webserver1   latest    8402b549b08e   11 minutes ago   236MB
      httpd2       latest    c368da710da1   47 minutes ago   167MB
      httpd        latest    bf308a6b9277   55 minutes ago   167MB
-->docker run -dt -p 8084:5000 --name webcontainer2 webserver2
   -->Here 5000 is the default port for python flask.
-->docker ps
   -->CONTAINER ID   IMAGE        COMMAND                  CREATED             STATUS             PORTS                                       NAMES
      a6e0c353cdfe   webserver2   "python app.py"          6 seconds ago       Up 5 seconds       0.0.0.0:8084->5000/tcp, :::8084->5000/tcp   webcontainer2
      3c6bc7b2ef19   webserver1   "/usr/sbin/apache2ct…"   15 minutes ago      Up 15 minutes      0.0.0.0:8083->80/tcp, :::8083->80/tcp       webcontainer
      ec898f7068d5   httpd2       "httpd-foreground"       53 minutes ago      Up 53 minutes      0.0.0.0:8082->80/tcp, :::8082->80/tcp       httpd_container_2
      4f891972314d   httpd        "httpd-foreground"       About an hour ago   Up About an hour   0.0.0.0:8081->80/tcp, :::8081->80/tcp       httpd_container
-->Now we can access the application webpage by giving <public_ip_of_instance>:8084.



###########################################################################################################################################################################################
                                                                        ----- Docker DAY-3 -------    
###########################################################################################################################################################################################

============================================================================================================================================================================
# scenario :1 single stage after run maven manually, deploy war file on tomcat webapp by using docker file 
============================================================================================================================================================================
-->ls
   -->Docker_web  docker_python_flask-project  web1
-->rm -rf *
-->git clone https://github.com/CloudTechDevOps/project-1-maven-jenkins-CICD-docker-eks-.git
-->ls
   -->project-1-maven-jenkins-CICD-docker-eks-
-->cd project-1-maven-jenkins-CICD-docker-eks-
-->ls
   -->Dockerfile  README.md  pom.xml  regapp-deploy.yml  server  webapp
-->vi Dockerfile
   -->give cmd escape+:1,$d to delete all content.
   -->FROM tomcat:latest
      COPY webapp/target/webapp.war /usr/local/tomcat/webapps/webapp.war
      RUN cp -R  /usr/local/tomcat/webapps.dist/*  /usr/local/tomcat/webapps
   -->here the run cmd is to run the tomcat webpage , if it is not there then also tomcat will run but only the webapps page will work not the default tomcat webpage
-->docker build -t maven .
   -->it will show error as the instructions given are for tomcat when maven generates the war file but here we didnt run any maven cmd to generate war file.
-->cd webapp
-->ls
   -->pom.xml  src
   -->Here we can see there is no target 
-->cd ..
-->ls
   -->Dockerfile  README.md  pom.xml  regapp-deploy.yml  server  webapp
-->mvn package
-->cd webapp
-->ls
   -->pom.xml  src  target
-->Now that the source of docker file is ready we can run the docker file now
-->Now instead of installing tomcat virtualling we are using its image
-->docker build -t maven .
-->docker images
   -->REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
      maven        latest    eb4b7c8564a4   26 seconds ago   460MB
-->docker run -dt -p 8081:8080 maven
-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND             CREATED         STATUS         PORTS                                       NAMES
      ea0e58db898d   maven     "catalina.sh run"   4 seconds ago   Up 3 seconds   0.0.0.0:8081->8080/tcp, :::8081->8080/tcp   determined_banach
-->Now we can access the application webpage by giving <public_ip_of_instance>:8081 and <public_ip_of_instance>:8081/webapp.
-->Here we have done the process half manually and half automatically using dockerfile.


=============================================================================================
scenario :2 multi satge --run Maven Image by using docker file and deploy on tomcat webapp
=============================================================================================
-->ls
   -->Dockerfile  README.md  pom.xml  regapp-deploy.yml  server  webapp
-->vi Dockerfile
   -->FROM maven:3.8.4-eclipse-temurin-17 AS build
      RUN mkdir /app
      WORKDIR /app
      COPY . .
      RUN mvn package

      FROM tomcat:latest
      COPY --from=build /app/webapp/target/webapp.war /usr/local/tomcat/webapps/webapp.war # copying files fromsta ge -1 docker file maven into tomcat path
      RUN cp -R  /usr/local/tomcat/webapps.dist/*  /usr/local/tomcat/webapps # adding dependecnes to run base tomcat page 

-->cd webapp
-->ls
   -->pom.xml  src  target
-->rm -rf target
-->ls
   -->pom.xml  src 
-->cd .. 
-->docker build -t maventomcat .
-->docker images
   -->REPOSITORY    TAG       IMAGE ID       CREATED              SIZE
      maventomcat   latest    8737a8acb939   About a minute ago   460MB
-->docker run -dt -p 8081:8080 maventomcat
-->docker ps
   -->CONTAINER ID   IMAGE         COMMAND             CREATED         STATUS         PORTS                                       NAMES
      aac8aa337144   maventomcat   "catalina.sh run"   5 seconds ago   Up 4 seconds   0.0.0.0:8081->8080/tcp, :::8081->8080/tcp   trusting_thompson
-->Now we can access the application webpage by giving <public_ip_of_instance>:8081 and <public_ip_of_instance>:8081/webapp.
-->Now we should push this repository to somewhere, So there are two ways
   1)AWS ECR
   2)Docker hub private repository
======================================================================================
Docker hub process
======================================================================================
-->Go to https://hub.docker.com/ and sign up
-->docker login
   -->username:praneeth9630
      password:xxxxxxxxxxxx
-->docker tag maventomcat praneeth9630/maventomcat
-->docker images
   -->REPOSITORY                 TAG       IMAGE ID       CREATED          SIZE
      maventomcat                latest    8737a8acb939   22 minutes ago   460MB
      praneeth9630/maventomcat   latest    8737a8acb939   22 minutes ago   460MB
-->docker push praneeth9630/maventomcat
-->Now we can check in https://hub.docker.com/ ther will be a repository created

======================================================================================
AWS ECR process
======================================================================================
-->First go to AWS ECR and create a repository with the same name as image.
-->after creating click on the repository name and click on view push commands it will show us the process to push the image to ECR
-->aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 508274233605.dkr.ecr.us-east-1.amazonaws.com
  --> it will show us a error as we are not able to internally connect between ec22 and ecr so we have to create a role.
-->Go to iam -> Roles -> create a role for ec2 with administrative access
-->Go to ec2 and select the instance ->actions->security->Modify iam role->attach ec2-ecr role to it.
-->aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 508274233605.dkr.ecr.us-east-1.amazonaws.com
-->docker tag maventomcat:latest 508274233605.dkr.ecr.us-east-1.amazonaws.com/maventomcat:latest
-->docker images
   -->REPOSITORY                                                 TAG       IMAGE ID       CREATED          SIZE
      508274233605.dkr.ecr.us-east-1.amazonaws.com/maventomcat   latest    8737a8acb939   37 minutes ago   460MB
      maventomcat                                                latest    8737a8acb939   37 minutes ago   460MB
      praneeth9630/maventomcat                                   latest    8737a8acb939   37 minutes ago   460MB
-->docker push 508274233605.dkr.ecr.us-east-1.amazonaws.com/maventomcat:latest
-->Now if check in AWS ECR maventomcat registery there will be a image stored init.
-->
======================================================================================
RUN DOCKER FILE DIRECTLY TAKING SOURCE FROM GITHUB 
======================================================================================
Command is docker build -t <imagename> <github projecturl>
Example:
docker build -t mvntomgit https://github.com/CloudTechDevOps/project-1-maven-jenkins-CICD-docker-eks-.git

-->cd ..
-->docker build -t mvntomgit https://github.com/CloudTechDevOps/project-1-maven-jenkins-CICD-docker-eks-.git
-->docker images
   -->REPOSITORY                                                 TAG       IMAGE ID       CREATED          SIZE
      mvntomgit                                                  latest    41c2da95378c   21 seconds ago   460MB
      maventomcat                                                latest    8737a8acb939   43 minutes ago   460MB
      praneeth9630/maventomcat                                   latest    8737a8acb939   43 minutes ago   460MB
      508274233605.dkr.ecr.us-east-1.amazonaws.com/maventomcat   latest    8737a8acb939   43 minutes ago   460MB


======================================================================================
Building an image other than Dockerfile
======================================================================================
### if we create multiple docker files like Dockerfile and Dockerfile1
###docker build -f <Dockerfilename> -t <imagename>.

-->vi testfile
   -->FROM ubuntu
-->docker build -f testfile -t myimage .
-->docker images
   -->REPOSITORY                                                 TAG       IMAGE ID       CREATED          SIZE
      mvntomgit                                                  latest    41c2da95378c   5 minutes ago    460MB
      508274233605.dkr.ecr.us-east-1.amazonaws.com/maventomcat   latest    8737a8acb939   48 minutes ago   460MB
      maventomcat                                                latest    8737a8acb939   48 minutes ago   460MB
      praneeth9630/maventomcat                                   latest    8737a8acb939   48 minutes ago   460MB
      myimage                                                    latest    d7413dc260c0   2 weeks ago      77.9MB

======================================================================================
# scenario :3 multi stage from ubuntu scratch by using docker file
======================================================================================

-->vi Dockerfile
   -->
FROM ubuntu:latest as builder
RUN apt-get update && \
    apt-get install -y openjdk-11-jdk wget unzip

ARG MAVEN_VERSION=3.9.6
RUN wget https://dlcdn.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.tar.gz && \
    tar -zxvf apache-maven-${MAVEN_VERSION}-bin.tar.gz && \
    rm apache-maven-${MAVEN_VERSION}-bin.tar.gz && \
    mv apache-maven-${MAVEN_VERSION} /usr/lib/maven

ENV MAVEN_HOME /usr/lib/maven
ENV MAVEN_CONFIG "$USER_HOME_DIR/.m2"
ENV PATH=$MAVEN_HOME/bin:$PATH
RUN mkdir -p /app
COPY . /app
WORKDIR /app
RUN mvn install


FROM tomcat:latest
COPY --from=builder /app/webapp/target/webapp.war /usr/local/tomcat/webapps/webapp.war
RUN cp -R  /usr/local/tomcat/webapps.dist/*  /usr/local/tomcat/webapps



-->docker build -t myimage2 .
-->docker images
   -->REPOSITORY                                                 TAG       IMAGE ID       CREATED              SIZE
      myimage2                                                   latest    8b59065dc12d   About a minute ago   460MB
      mvntomgit                                                  latest    41c2da95378c   13 minutes ago       460MB
      508274233605.dkr.ecr.us-east-1.amazonaws.com/maventomcat   latest    8737a8acb939   56 minutes ago       460MB
      maventomcat                                                latest    8737a8acb939   56 minutes ago       460MB
      praneeth9630/maventomcat                                   latest    8737a8acb939   56 minutes ago       460MB
      myimage                                                    latest    d7413dc260c0   2 weeks ago          77.9MB



###########################################################################################################################################################################################
                                                                        ----- Docker DAY-4 -------    
###########################################################################################################################################################################################

-->Docker Volume
   -->By default docker container volumes ephimeral storage(ephimeral means temporary)
   -->Whenever container is deleted the volume is also deleted as it is inbuilt nature
   -->We are going to directly create volume on docker host(docker server) containers access the volume directly 
-->docker container ls (or) docker ps
-->docker container ls -a (or) docker ps -a
-->docker volume create volume1
   -->To create a volume
-->docker volume ls
   -->DRIVER    VOLUME NAME
      local     volume1
-->docker inspect volume volume1
   -->[
    {
        "CreatedAt": "2024-03-16T11:12:22Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/volume1/_data",
        "Name": "volume1",
        "Options": null,
        "Scope": "local"
    }
]
   -->to inspect about the volume
-->docker volume rm volume1
   -->To remove the volume
-->docker volume create volume1
-->docker run -it --name container1 -v volume1:/volume1 ubuntu
  --> this cmd runs the container on the volume 1
-->ls
   -->bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume1
-->Cntl+pq
-->docker run -it --name container2 ubuntu
-->ls
   -->bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
-->Cntl+pq
-->docker run -it --name container3 -v volume1:/volume1 ubuntu
-->cd volume1
-->ls
-->echo hi hello > file1
-->cat file1
   -->hi hello
-->Cntl+pq
-->docker run -it --name=container4 --volumes-from container3 ubuntu
   -->
-->ls
   -->bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume1
-->cd volume1
-->ls
   -->file1
-->cat file1
   -->hi hello
-->Cntl+pq


-->The three types of docker networking are
   1)Bridge Network
   2)None Network
   3)Host Network

-->docker ps
   -->CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
      10b16c4643e2   ubuntu    "/bin/bash"   7 minutes ago    Up 7 minutes              container4
      c61403fb6628   ubuntu    "/bin/bash"   12 minutes ago   Up 12 minutes             container3
      9aa68b69dc99   ubuntu    "/bin/bash"   18 minutes ago   Up 18 minutes             container1
-->docker exec -it container3 /bin/bash


##############################################################
-->docker run -dt -p 8081:80 --name c1 ubuntu
-->docker run -dt -p 8082:80 --name c2 nginx
-->docker inspect container c1
   -->
"NetworkSettings": {
            "Bridge": "",
            "SandboxID": "301350b3ef332feb2379ab37b317ed549764637a336f84f7d323c02f89bfb416",
            "SandboxKey": "/var/run/docker/netns/301350b3ef33",
            "Ports": {},
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "61b28808e4fdae5783010e91298c91ebe692f8f46873065d486f748ee6932452",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,

-->docker inspect container c2
   -->
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "MacAddress": "02:42:ac:11:00:03",
                    "NetworkID": "9cabf2810f6ef02f661adb34df3abcb031ca4dbd2b71eecb1e2c612d3f29b89b",
                    "EndpointID": "60fc97c586698389cd9723a830a6552a479b32b85090701c7b4108ae1998ee3b",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.3",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "DriverOpts": null,
                    "DNSNames": null
-->docker exec -it c2 /bin/bash
   -->root@ea95fe913766:/# ping 172.17.0.2
      -->it shows ping cmd not found
   -->##instal ping
   -->apt-get update -y
   -->apt install iputils-ping
-->root@ea95fe913766:/# ping 172.17.0.2
   -->PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=127 time=0.085 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=127 time=0.061 ms
64 bytes from 172.17.0.2: icmp_seq=3 ttl=127 time=0.069 ms
64 bytes from 172.17.0.2: icmp_seq=4 ttl=127 time=0.063 ms
64 bytes from 172.17.0.2: icmp_seq=5 ttl=127 time=0.065 ms
64 bytes from 172.17.0.2: icmp_seq=6 ttl=127 time=0.064 ms
64 bytes from 172.17.0.2: icmp_seq=7 ttl=127 time=0.067 ms
64 bytes from 172.17.0.2: icmp_seq=8 ttl=127 time=0.068 ms
64 bytes from 172.17.0.2: icmp_seq=9 ttl=127 time=0.070 ms
-->
-->docker run -dt --name container5 --network host nginx
   -->here we are running the container on specific(host) network.
-->



###########################################################################################################################################################################################
                                                                        ----- Docker DAY-5 -------    
###########################################################################################################################################################################################



-->sudo su -
-->ls
   -->
-->mkdir python
-->cd python
-->vi Dockerfile
   -->
FROM ubuntu:latest
WORKDIR /app
COPY . /app
RUN apt-get -y update && apt-get install -y python
ENTRYPOINT ["python"]
CMD ["python", "app.py"]

-->vi app.py
   -->
print("Hello World")

-->docker build -t python .
   -->it will not work properly
-->vi Dockerfile
   -->
FROM python:latest
WORKDIR /app
COPY . /app
RUN apt-get -y update && apt-get install -y python
ENTRYPOINT ["python"]
CMD ["python", "app.py"]

-->docker build -t python .
   -->it will work properly
-->docker images
-->docker run -dt python


######### CMD vs Entrypoint  ###

FROM centos:centos7
CMD ["yum", "install", "-y", "httpd"]
     
note: condition:1 after we run command docker run image ----it will install httpd   

note: condition -2 if we run docker run image yum install -y git it will overwrite new command it will download git only and ignores httpd
but i need only allow required attribute change like httpd, git ex : docker run image httpd or git  instead of docker run image yum install -y httpd or git

##### Entrypoint
FROM centos:centos7
ENTRYPOINT ["yum", "install", "-y", "git"] 
note: condition:1 after run command docker run image ----it will install git  
      condition -2 if we run docker run image httpd ----it will install git and httpd also  

FROM centos:centos7
ENTRYPOINT ["yum", "install", "-y"]
CMD ["git"] 

-->

===========================================================================================
sudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose

sudo chmod +x /usr/local/bin/docker-compose
- - - - - - - -- - - - - - - - -- - -  - - -- -  -
docker-compose version
services:
  mydb:
    environment:
      MYSQL_ROOT_PASSWORD: test
    image: mysql
  mysite:
    image: wordpress
    links:
    - mydb:site
    ports:
    - published: 8080
      target: 80
version: '3'

filename : docker-compose.yaml

<docker-compose -f filename.yaml up> need to give this command for custom file name 
docker-compose up -----#to run docker compose 
docker-compose ps -----#to see containers status

########### list of commands on Docker compose ######
Docker-Compose commands.
To pull docker images.
docker-compose pull

To create all containers using docker-compose file.
docker-compose up

To create all containers using docker-compose file with detached mode.
docker-compose up -d

To stop all running containers with docker-compose.
docker-compose stop

To view the config file.
docker-compose config

To remove all stopped containers.
docker-compose rm

To view the logs of all containers.
docker-compose logs

To view all images.
docker-compose images

To view all contaiers created by docker-compose file.
docker-compose ps

To restart containers with docker-compose file.
docker-compose restart


===========================================================================================
-->Docker compose files support yaml file
-->Docker compose is used to deploy multiple images and run multiple containers
-->Docker compose files we can add multiple paths to deploy
-->All cmds start with docker-compose
===========================================================================================

-->cd Docker_compose
-->vi compose.yaml
   -->
services:
  mydb:
    environment:
      MYSQL_ROOT_PASSWORD: test
    image: mysql
  mysite:
    image: wordpress
    links:
    - mydb:site
    ports:
    - published: 8080
      target: 80
version: '3'

-->docker-compose -f compose.yaml up
-->docker images
   -->2 images with names of wordpress and mysql
-->docker-compose start
-->docker ps
   -->2 containers


###########################################################################################################################################################################################
                                                                        ----- Docker Sir Notes -------    
###########################################################################################################################################################################################


-----docker install process -------


sudo amazon-linux-extras install docker # if linux 2

sudo yum install docker -y # If linux 20203

sudo systemctl start docker
sudo systemctl status docker

Note : By default Docker works with the root user and other users can only access to Docker with sudo commands. However, we can bypass the sudo commands by creating a new group with the name docker and add ec2_user.

#First let’s create the docker group

sudo groupadd docker (optional if group is not created)

#Now let’s add ec2-user to docker group

sudo usermod -a -G docker ec2-user

#In order to enable the changes, run the following command

newgrp docker 

sudo chmod 666 /var/run/docker.sock  # to give access docker demon to run docker server 

docker --version to check docker version

#If you want to see an extended version of the version details, such as the API version, Go version, and Engine Version, use the version command without dashes. give below command

docker version 


# ----commands:---- #

---to pull base images from public docker repository

docker pull image <imagename>

docker pull nginx or ubuntu


docker inspect image nginx  ### to check images details 
docker images # to check list of images 

docker run -it imagename /bin/bash  --will enter into the container interact terminal 

docker run -dt imagename -we are not enter into the container detach terminal

docker run -dt --name <name> <imagename> 
 (to give csutome name --name)


docker ps ## to check running containers 

docker ps -a  ## to check both running and stopped containers 




## To login container ##
docker exec -it <continername or continerid> /bin/bash

1.if you want to come out from connainer without stop give "ctrl+pq"
2.if you give "exit"  container also will stop

ps -ef   --to know how many processors runing if it is in vm many process we can see but it is in container onle few becuase its light weight 

ps -ef | wc -l #to know number of processors request running backend






#### how to start container#####

docker start <containerid>
          or
docker start <container name>

#### how to stop container#####
docker stop <containerid> 
           or
docker stop <container name>

## docker kill comeplete terminated 
docker kill <containername>

docker pause cont_name	: to pause container
docker unpause cont_name: to unpause container
docker inspect cont_name: to get complete info of a container



## danger commands##

docker system prune -a to remove all images 
docker container prune -- delete all stoped containers 
docker rm -f $(docker ps -a -q)  ---delete all runnig containers Note: please dont use danger command

docker rm <containername or continerid> ### to remover stopped container 
docker rmi <imagename> ##to delete image 

docker rm -f <continer id> delete runing continer 

# --Enabeling port-- #

docker run -p <HOST_PORT>:<CONTAINER:PORT> IMAGE_NAME  

docker run -dt -p 3000:3000 --name project-2 saturday   #along port expose

===================================================================================

-------- pull jenkins----------

docker pull jenkins/jenkins

docker run -dt -p <local host port>:<container run port> --name <name of the container> <name of the image>

docker run -dt -p 8081:8080 --name jenkins container jenkins/jenkin

access the jenkins with public ip and port number (8081)







=======================================================================================

------------# Docker file runn commands #----------
Dockerfile is a simple text file that consists of instructions to build Docker images.
-----------------------------------
##### Docker file instruiction ########

From : to pull base image
Run : to excutive commands
CMD : To Provide defaults for an executing container 
Entrypoint : To configure a container that will run as an container
Workdir : to set working directory
Copy: files form local to the container
Add: TO copy files and loader file but little advance add command we can add url also 
Expose : informs docker that the container listen on the specified network port runtime
Env: To set env variabels 

# below command to run docker file

docker build -t check .
docker run -p <HOST_PORT>:<CONTAINER:PORT> IMAGE_NAME
docker run -dit --name demo -p 8080:80 check
ex: docker run -dt -p 3000:3000 --name project-2 saturday




Ex: 1

# Ex:1 docker pull httpd (readymade)

FROM httpd:2.4
COPY ./public-html/ /usr/local/apache2/htdocs/ # copy present directory files into destination patha tha is /usr/local/apache2/htdocs/

Ex:2

# httpd with ubuntu (impliment from scratch)

FROM ubuntu #pull ubuntu base image from docker hub
RUN apt update
RUN apt-get -y  update
RUN apt-get -y install apache2 #by using RUN instrcution install apache2
COPY index.html  /var/www/html #copying index.html file into /var/www/html
EXPOSE 80 #expose default port number for application
CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"] #Run apache2 srever while running container from image

Note:
-D FOREGROUND This is not a docker command this is Apache server argument which is used to run the web server in the background. If we do not use this argument the server will start and then it will stop

# Ex:3 httpd with centos

FROM centos:7
RUN yum update -y && yum install -y httpd
COPY index.html /var/www/html/
EXPOSE 80
#httpdserver
CMD ["/usr/sbin/httpd", "-D", "FOREGROUND"]


=============================================================
              #  IMAGE PUSH #
======================================================================

######### docker push to Docker private repository  #########
docker login first
docker tag <image> dockerusername/<image>
docker push <dockerusername>/<image>
docker pull <dockerusername>/<image>

================================================================

######### docker push to AWS ECR  #########

Retrieve an authentication token and authenticate your Docker client to your registry.
Use the AWS CLI:

aws ecr get-login-password --region ap-south-1 | docker login --username AWS --password-stdin 992382358200.dkr.ecr.ap-south-1.amazonaws.com
Note: If you receive an error using the AWS CLI, make sure that you have the latest version of the AWS CLI and Docker installed.
Build your Docker image using the following command. For information on building a Docker file from scratch see the instructions here . You can skip this step if your image is already built:

docker build -t maventomcat .
After the build completes, tag your image so you can push the image to this repository:

docker tag maventomcat:latest 992382358200.dkr.ecr.ap-south-1.amazonaws.com/maventomcat:latest
Run the following command to push this image to your newly created AWS repository:

docker push 992382358200.dkr.ecr.ap-south-1.amazonaws.com/maventomcat:latest


==================================================================================

----- ## Docker file single stage and multi stage ##--------
======================================================================================
# scenario :1 single stage after run mavne manually, deploy war file on tomcat webapp by using docker file 

FROM tomcat:latest
COPY webapp/target/webapp.war /usr/local/tomcat/webapps/webapp.war
RUN cp -R  /usr/local/tomcat/webapps.dist/*  /usr/local/tomcat/webapps


# scenario :2 multi satge --run Maven Image by using docker file and deploy on tomcat webapp

FROM maven:3.8.4-eclipse-temurin-17 AS build
RUN mkdir /app
WORKDIR /app
COPY . .
RUN mvn package

FROM tomcat:latest
COPY --from=build /app/webapp/target/webapp.war /usr/local/tomcat/webapps/webapp.war # copying files fromsta ge -1 docker file maven into tomcat path
RUN cp -R  /usr/local/tomcat/webapps.dist/*  /usr/local/tomcat/webapps # adding dependecnes to run base tomcat page 


# scenario :3 multi stage from ubuntu scratch by using docker file 

FROM ubuntu:latest as builder
RUN apt-get update && \
     apt-get install -y openjdk-8-jdk wget unzip

ARG MAVEN_VERSION=3.9.6
RUN wget https://dlcdn.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.tar.gz && \
    tar -zxvf apache-maven-${MAVEN_VERSION}-bin.tar.gz && \
    rm apache-maven-${MAVEN_VERSION}-bin.tar.gz && \
    mv apache-maven-${MAVEN_VERSION} /usr/lib/maven

ENV MAVEN_HOME /usr/lib/maven
ENV MAVEN_CONFIG "$USER_HOME_DIR/.m2"
ENV PATH=$MAVEN_HOME/bin:$PATH
RUN mkdir -p /app
COPY . /app
 WORKDIR /app
 RUN mvn install


FROM tomcat:latest
COPY --from=builder /app/webapp/target/webapp.war /usr/local/tomcat/webapps/webapp.war
RUN cp -R  /usr/local/tomcat/webapps.dist/*  /usr/local/tomcat/webapps

====================================================
    # Custom Docker file name #

# if we create multiple docker files like Dockerfile and Dockerfile1 

Below command example to run

docker build -f <Dockerfilename> -t <imagename>.


docker build -f Dockerfile1 -t image .


====================================================
RUN DOCKER FILE DIRECTLY TAKING SOURCE FROM GITHUB 
======================================================
docker build -t <imagename> <github projecturl>

Example:

docker build -t mvntomgit https://github.com/CloudTechDevOps/project-1-maven-jenkins-CICD-docker-eks-.git

Day-4

######### CMD vs Entrypoint  ###

FROM centos:centos7
CMD ["yum", "install", "-y", "httpd"]
     
note: condition:1 after run command docker run image ----it will install httpd   

note: condition -2 if we run docker run image yum install -y git it will overwrite new command it will download git only and ignores httpd
but i need only allow required attribute change like httpd, git ex : docker run image httpd or git  instead of docker run image yum install -y httpd or git

##### Entrypoint
FROM centos:centos7
ENTRYPOINT ["yum", "install", "-y", "git"] 
note: condition:1 after run command docker run image ----it will install git  
      condition -2 if we run docker run image httpd ----it will install git and httpd also  

FROM centos:centos7
ENTRYPOINT ["yum", "install", "-y"]
CMD ["git"] 






######## network ##############
##bridge
##host
##none
docker run -dt --name container1 ubuntu
docker network ls
create two containers 
container1
container2
docker inspect <containername>

container1: 172.17.0.2
container2: 172.17.0.3

Note:defualt network is bridge 

login to container 
docker exec -it <containernmae> /bin/bash

## need to install ping libraries by using below command (if ping command will not work)

#apt-get update -y

#apt install iputils-ping
  
check both containers ips and try to access each other 



# host type

Docker network host, also known as Docker host networking, is a networking mode in which a Docker container shares its network namespace with the host machine. The application inside the container can be accessed using a port at the host's IP address 

docker run -dt --name <container> --network host <image>
ex:docker run -d --network host nginx

#None type 

none network in docker means when you don't want any network interface for your container. If you want to completely disable the networking on a container, you can use the --network none flag when starting the container.

docker run -dt --name <container> --network None ubuntu


#to remove network : docker network rm networkname



# create cutome network # (optional)

docker network create <networkname> # to maitain private connection one container from another container


docker run -dt --name <container-name> --network <created-networkname> <image-name>
ex: docker run -dt --name container3 --network private ubuntu


##########################################################
---------------Docker volumes ----------

Volumes are a mechanism for storing data outside containers. All volumes are managed by Docker and stored in a dedicated directory on your host, usually /var/lib/docker/volumes for Linux systems.

### to create volume
docker volume create <volume-name>
docker volume ls ##to check list of volumes
docker inspect volume <volumename>
docker volume rm <volumename> ## to remove volume
### to check created volume path
cd /var/lib/docker/volumes

## run container from ubuntu image along with created volume 
docker run -ti --name=container1 -v volume1:/volume1 ubuntu

docker run -ti --name=container1 -v wed:/wed ubuntu


docker run -ti --name=container2 --volumes-from container1 ubuntu

echo "Share this file between containers">/volume1/Example.txt


--------docker compose installation ------------

sudo curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose

sudo chmod +x /usr/local/bin/docker-compose
- - - - - - - -- - - - - - - - -- - -  - - -- -  -
docker-compose version
services:
  mydb:
    environment:
      MYSQL_ROOT_PASSWORD: test
    image: mysql
  mysite:
    image: wordpress
    links:
    - mydb:site
    ports:
    - published: 8080
      target: 80
version: '3'

filename : docker-compose.yaml

<docker-compose -f filename.yaml up> need to give this command for custom file name 
docker-compose up -----#to run docker compose 
docker-compose ps -----#to see containers status

########### list of commands on Docker compose ######
Docker-Compose commands.
To pull docker images.
docker-compose pull

To create all containers using docker-compose file.
docker-compose up

To create all containers using docker-compose file with detached mode.
docker-compose up -d

To stop all running containers with docker-compose.
docker-compose stop

To view the config file.
docker-compose config

To remove all stopped containers.
docker-compose rm

To view the logs of all containers.
docker-compose logs

To view all images.
docker-compose images

To view all contaiers created by docker-compose file.
docker-compose ps

To restart containers with docker-compose file.
docker-compose restart




























